<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code Generator with Brush Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
      color: #333;
    }
    main {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      padding: 20px;
      width: 90%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    #qr-text {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 16px;
    }
    #upload-area {
      border: 2px dashed #aaa;
      padding: 20px;
      text-align: center;
      background: #fafafa;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #upload-area.dragover {
      background: #e0e0e0;
    }
    #preview-container {
      position: relative;
      width: 100%;
      max-width: 300px;
      height: 300px;
      border: 1px solid #ddd;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      align-self: center;
    }
    #qr-canvas {
      width: 100%;
      height: 100%;
    }
    #brush-silhouette {
      position: absolute;
      pointer-events: none;
      border: 1px dashed #666;
      border-radius: 50%;
      display: none;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .section {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #eee;
    }
    .section-title {
      font-weight: 600;
      margin-bottom: 10px;
      font-size: 16px;
      color: #555;
    }
    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .control-group label {
      font-size: 14px;
      margin-bottom: 5px;
      color: #666;
    }
    input[type="range"], select, input[type="color"] {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
    }
    button {
      padding: 10px 20px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    .checkbox-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .slider-value {
      font-size: 12px;
      color: #777;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <main>
    <input type="text" id="qr-text" placeholder="Enter text for QR code">
    <div id="upload-area">
      <p>Drag or click to upload logo (PNG, JPG, SVG)</p>
      <input type="file" id="logo-upload" accept="image/*" style="display: none;">
    </div>
    <div id="controls">
      <div class="section">
        <div class="section-title">QR Code Settings</div>
        <div class="control-grid">
          <div class="control-group">
            <label for="scale-slider">Logo Scale: <span class="slider-value" id="scale-slider-value">1.0</span></label>
            <input type="range" id="scale-slider" min="0.1" max="2" step="0.1" value="1">
          </div>
          <div class="control-group">
            <label for="error-correction">Error Correction</label>
            <select id="error-correction">
              <option value="L">L (7%)</option>
              <option value="M" selected>M (15%)</option>
              <option value="Q">Q (25%)</option>
              <option value="H">H (30%)</option>
            </select>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="smooth-corners">
            <label for="smooth-corners">Smooth Corners</label>
          </div>
          <div class="control-group">
            <label for="roundness">Corner Roundness: <span class="slider-value" id="roundness-value">0.5</span></label>
            <input type="range" id="roundness" min="0" max="1" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="black-color-picker">Black Pixel Color</label>
            <input type="color" id="black-color-picker" value="#000000">
          </div>
          <div class="control-group">
            <label for="white-color-picker">White Pixel Color</label>
            <input type="color" id="white-color-picker" value="#FFFFFF">
          </div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Brush Tool</div>
        <div class="control-grid">
          <div class="control-group">
            <label for="brush-radius">Brush Radius: <span class="slider-value" id="brush-radius-value">3</span></label>
            <input type="range" id="brush-radius" min="1" max="10" step="1" value="3">
          </div>
          <div class="control-group">
            <label for="brush-strength">Strength (Min Size): <span class="slider-value" id="brush-strength-value">0.5</span></label>
            <input type="range" id="brush-strength" min="0.1" max="1.0" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="brush-intensity">Intensity/Speed: <span class="slider-value" id="brush-intensity-value">0.05</span></label>
            <input type="range" id="brush-intensity" min="0.01" max="0.1" step="0.01" value="0.05">
          </div>
          <div class="control-group">
            <label for="brush-transparency">Max Transparency: <span class="slider-value" id="brush-transparency-value">0.5</span></label>
            <input type="range" id="brush-transparency" min="0.0" max="1.0" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="rotation-speed">Rotation Speed: <span class="slider-value" id="rotation-speed-value">0°</span></label>
            <input type="range" id="rotation-speed" min="-0.5" max="0.5" step="0.05" value="0">
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-scale">
            <label for="lock-scale">Lock Scale</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-rotation">
            <label for="lock-rotation">Lock Rotation</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-transparency">
            <label for="lock-transparency">Lock Transparency</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-scale">
            <label for="jitter-scale">Jitter Scale</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-rotation">
            <label for="jitter-rotation">Jitter Rotation</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-color">
            <label for="jitter-color">Jitter Color (Black Pixels)</label>
          </div>
        </div>
        <div class="button-group">
          <button id="brush-toggle">Enable Brush</button>
          <button id="reset-rotation-btn">Reset Rotation</button>
          <button id="reset-colors-btn">Reset Colors</button>
          <button id="reset-scale-btn">Reset Scale</button>
          <button id="reset-transparency-btn">Reset Transparency</button>
          <button id="reset-all-btn">Reset All</button>
          <button id="undo-btn">Undo</button>
          <button id="redo-btn">Redo</button>
        </div>
      </div>
    </div>
    <div id="preview-container">
      <canvas id="qr-canvas"></canvas>
      <div id="brush-silhouette"></div>
    </div>
    <button id="download-btn">Download QR Code (SVG)</button>
  </main>
  <script>
    // QR Code Generator with Strategy Pattern for Color Handling
    class QRCodeGenerator {
      constructor() {
        this.elements = this.initializeElements();
        this.state = this.initializeState();
        this.colorStrategy = new DefaultColorStrategy();
        this.initializeEventListeners();
        this.generateQRCode();
      }

      initializeElements() {
        return {
          qrText: document.getElementById('qr-text'),
          logoUpload: document.getElementById('logo-upload'),
          scaleSlider: document.getElementById('scale-slider'),
          errorCorrection: document.getElementById('error-correction'),
          smoothCorners: document.getElementById('smooth-corners'),
          roundnessSlider: document.getElementById('roundness'),
          brushRadius: document.getElementById('brush-radius'),
          brushStrength: document.getElementById('brush-strength'),
          brushIntensity: document.getElementById('brush-intensity'),
          brushTransparency: document.getElementById('brush-transparency'),
          rotationSpeed: document.getElementById('rotation-speed'),
          lockScale: document.getElementById('lock-scale'),
          lockRotation: document.getElementById('lock-rotation'),
          lockTransparency: document.getElementById('lock-transparency'),
          jitterScale: document.getElementById('jitter-scale'),
          jitterRotation: document.getElementById('jitter-rotation'),
          jitterColor: document.getElementById('jitter-color'),
          blackColorPicker: document.getElementById('black-color-picker'),
          whiteColorPicker: document.getElementById('white-color-picker'),
          brushToggle: document.getElementById('brush-toggle'),
          resetRotationBtn: document.getElementById('reset-rotation-btn'),
          resetColorsBtn: document.getElementById('reset-colors-btn'),
          resetScaleBtn: document.getElementById('reset-scale-btn'),
          resetTransparencyBtn: document.getElementById('reset-transparency-btn'),
          resetAllBtn: document.getElementById('reset-all-btn'),
          undoBtn: document.getElementById('undo-btn'),
          redoBtn: document.getElementById('redo-btn'),
          previewContainer: document.getElementById('preview-container'),
          uploadArea: document.getElementById('upload-area'),
          downloadBtn: document.getElementById('download-btn'),
          qrCanvas: document.getElementById('qr-canvas'),
          brushSilhouette: document.getElementById('brush-silhouette'),
          ctx: document.getElementById('qr-canvas').getContext('2d')
        };
      }

      initializeState() {
        return {
          logoImage: new Image(),
          logoScale: 1,
          qrCode: null,
          logoBounds: null,
          logoSVGCode: null,
          brushedModules: new Map(),
          history: [],
          historyIndex: -1,
          isBrushing: false,
          brushEnabled: false,
          blackColor: '#000000',
          whiteColor: '#FFFFFF'
        };
      }

      initializeEventListeners() {
        const sliders = [
          { el: this.elements.scaleSlider, display: 'scale-slider-value', format: v => v },
          { el: this.elements.brushRadius, display: 'brush-radius-value', format: v => v },
          { el: this.elements.brushStrength, display: 'brush-strength-value', format: v => v },
          { el: this.elements.brushIntensity, display: 'brush-intensity-value', format: v => v },
          { el: this.elements.brushTransparency, display: 'brush-transparency-value', format: v => v },
          { el: this.elements.rotationSpeed, display: 'rotation-speed-value', format: v => `${v}°` },
          { el: this.elements.roundnessSlider, display: 'roundness-value', format: v => v }
        ];
        sliders.forEach(slider => {
          slider.el.addEventListener('input', () => {
            document.getElementById(slider.display).textContent = slider.format(slider.el.value);
            if (slider.el === this.elements.scaleSlider) {
              this.state.logoScale = parseFloat(slider.el.value);
              this.updateLogoBounds();
            }
            this.drawPreview();
          });
        });

        this.elements.blackColorPicker.addEventListener('input', () => { this.state.blackColor = this.elements.blackColorPicker.value; this.drawPreview(); });
        this.elements.whiteColorPicker.addEventListener('input', () => { this.state.whiteColor = this.elements.whiteColorPicker.value; this.drawPreview(); });
        this.elements.uploadArea.addEventListener('click', () => this.elements.logoUpload.click());
        this.elements.logoUpload.addEventListener('change', (event) => this.loadLogo(event.target.files[0]));
        this.elements.uploadArea.addEventListener('dragover', (event) => {
          event.preventDefault();
          this.elements.uploadArea.classList.add('dragover');
        });
        this.elements.uploadArea.addEventListener('dragleave', () => this.elements.uploadArea.classList.remove('dragover'));
        this.elements.uploadArea.addEventListener('drop', (event) => {
          event.preventDefault();
          this.elements.uploadArea.classList.remove('dragover');
          const file = event.dataTransfer.files[0];
          if (file && file.type.startsWith('image/')) this.loadLogo(file);
        });
        this.elements.qrText.addEventListener('input', () => this.generateQRCode());
        this.elements.errorCorrection.addEventListener('change', () => this.generateQRCode());
        this.elements.smoothCorners.addEventListener('change', () => this.drawPreview());
        this.elements.brushToggle.addEventListener('click', () => this.toggleBrush());
        this.elements.qrCanvas.addEventListener('mousemove', (event) => this.handleMouseMove(event));
        this.elements.qrCanvas.addEventListener('mousedown', (event) => this.startBrushing(event));
        this.elements.qrCanvas.addEventListener('mouseup', () => this.stopBrushing());
        this.elements.resetRotationBtn.addEventListener('click', () => this.resetRotation());
        this.elements.resetColorsBtn.addEventListener('click', () => this.resetColors());
        this.elements.resetScaleBtn.addEventListener('click', () => this.resetScale());
        this.elements.resetTransparencyBtn.addEventListener('click', () => this.resetTransparency());
        this.elements.resetAllBtn.addEventListener('click', () => this.resetAll());
        this.elements.undoBtn.addEventListener('click', () => this.undo());
        this.elements.redoBtn.addEventListener('click', () => this.redo());
        this.elements.downloadBtn.addEventListener('click', () => this.downloadSVG());
        window.addEventListener('resize', () => this.drawPreview());
      }

      loadLogo(file) {
        const reader = new FileReader();
        if (file.type === 'image/svg+xml') {
          reader.onload = (e) => {
            let svgContent = e.target.result.replace(/<\?xml[^>]*\?>/, '').replace(/<!DOCTYPE[^>]*>/, '');
            this.state.logoSVGCode = svgContent;
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            this.state.logoImage.src = URL.createObjectURL(blob);
            this.state.logoImage.onload = () => { this.updateLogoBounds(); this.drawPreview(); };
          };
          reader.readAsText(file);
        } else {
          reader.onload = (e) => {
            this.state.logoImage.src = e.target.result;
            this.state.logoImage.onload = () => { this.updateLogoBounds(); this.drawPreview(); };
          };
          reader.readAsDataURL(file);
        }
      }

      updateLogoBounds() {
        if (!this.state.logoImage.src) return;
        const canvasSize = this.elements.previewContainer.clientWidth;
        const logoWidth = this.state.logoImage.width * this.state.logoScale;
        const logoHeight = this.state.logoImage.height * this.state.logoScale;
        this.state.logoBounds = {
          x: (canvasSize - logoWidth) / 2,
          y: (canvasSize - logoHeight) / 2,
          width: logoWidth,
          height: logoHeight
        };
      }

      generateQRCode() {
        if (this.elements.qrText.value) {
          this.state.qrCode = qrcode(0, this.elements.errorCorrection.value);
          this.state.qrCode.addData(this.elements.qrText.value);
          this.state.qrCode.make();
          this.state.brushedModules.clear();
          this.state.history = [];
          this.state.historyIndex = -1;
          this.drawPreview();
        } else {
          this.state.qrCode = null;
          this.drawPreview();
        }
      }

      getModuleProperties(i, j) {
        const key = `${i},${j}`;
        return this.state.brushedModules.get(key) || { scale: 1, transparency: 0, rotation: 0, sJitter: 0, lJitter: 0 };
      }

      drawPreview() {
        const canvasSize = this.elements.previewContainer.clientWidth;
        this.elements.qrCanvas.width = canvasSize;
        this.elements.qrCanvas.height = canvasSize;
        this.elements.ctx.clearRect(0, 0, canvasSize, canvasSize);

        if (this.state.logoImage.src) {
          this.elements.ctx.drawImage(this.state.logoImage, this.state.logoBounds.x, this.state.logoBounds.y, this.state.logoBounds.width, this.state.logoBounds.height);
        }

        if (this.state.qrCode) {
          const n = this.state.qrCode.getModuleCount();
          const moduleSize = canvasSize / n;

          if (this.elements.smoothCorners.checked) {
            const roundness = parseFloat(this.elements.roundnessSlider.value);
            this.drawPositionPatternCanvas(0, 0, moduleSize, roundness, this.state.blackColor, this.state.whiteColor);
            this.drawPositionPatternCanvas(0, n - 7, moduleSize, roundness, this.state.blackColor, this.state.whiteColor);
            this.drawPositionPatternCanvas(n - 7, 0, moduleSize, roundness, this.state.blackColor, this.state.whiteColor);
          }

          this.colorStrategy = this.elements.jitterColor.checked ? new JitterColorStrategy() : new DefaultColorStrategy();
          for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
              if (this.elements.smoothCorners.checked && this.isPositionPattern(i, j, n)) continue;
              const { scale, transparency, rotation, sJitter, lJitter } = this.getModuleProperties(i, j);
              const size = moduleSize * scale;
              const offset = (moduleSize - size) / 2;
              const x = j * moduleSize + offset;
              const y = i * moduleSize + offset;
              const centerX = x + size / 2;
              const centerY = y + size / 2;
              const baseColor = this.state.qrCode.isDark(i, j) ? this.state.blackColor : this.state.whiteColor;
              const finalColor = this.colorStrategy.applyColor(baseColor, this.state.qrCode.isDark(i, j), sJitter, lJitter);
              const gradient = this.elements.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
              gradient.addColorStop(0, finalColor);
              gradient.addColorStop(1, `rgba(${this.hexToRgb(finalColor).join(',')},${1 - transparency})`);
              this.elements.ctx.save();
              this.elements.ctx.translate(centerX, centerY);
              this.elements.ctx.rotate(rotation * Math.PI / 180);
              this.elements.ctx.translate(-centerX, -centerY);
              this.elements.ctx.fillStyle = gradient;
              this.elements.ctx.fillRect(x, y, size, size);
              this.elements.ctx.restore();
            }
          }
        }
      }

      hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
      }

      rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return [h, s, l];
      }

      hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r * 255, g * 255, b * 255];
      }

      drawPositionPatternCanvas(row, col, moduleSize, roundness, blackColor, whiteColor) {
        const x = col * moduleSize;
        const y = row * moduleSize;
        const outerRadius = roundness * (moduleSize * 3.5);
        const middleRadius = roundness * (moduleSize * 2.5);
        const innerRadius = roundness * (moduleSize * 1.5);
        this.elements.ctx.fillStyle = blackColor;
        this.drawRoundedRect(this.elements.ctx, x, y, 7 * moduleSize, 7 * moduleSize, outerRadius);
        this.elements.ctx.fillStyle = whiteColor;
        this.drawRoundedRect(this.elements.ctx, x + moduleSize, y + moduleSize, 5 * moduleSize, 5 * moduleSize, middleRadius);
        this.elements.ctx.fillStyle = blackColor;
        this.drawRoundedRect(this.elements.ctx, x + 2 * moduleSize, y + 2 * moduleSize, 3 * moduleSize, 3 * moduleSize, innerRadius);
      }

      drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.arcTo(x + width, y, x + width, y + radius, radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        ctx.lineTo(x + radius, y + height);
        ctx.arcTo(x, y + height, x, y + height - radius, radius);
        ctx.lineTo(x, y + radius);
        ctx.arcTo(x, y, x + radius, y, radius);
        ctx.closePath();
        ctx.fill();
      }

      isPositionPattern(i, j, n) {
        return (i < 7 && j < 7) || (i < 7 && j >= n - 7) || (i >= n - 7 && j < 7);
      }

      toggleBrush() {
        this.state.brushEnabled = !this.state.brushEnabled;
        this.elements.brushToggle.textContent = this.state.brushEnabled ? 'Disable Brush' : 'Enable Brush';
        this.elements.qrCanvas.style.cursor = this.state.brushEnabled ? 'crosshair' : 'default';
        this.elements.brushSilhouette.style.display = this.state.brushEnabled ? 'block' : 'none';
      }

      handleMouseMove(event) {
        if (this.state.brushEnabled) {
          const rect = this.elements.qrCanvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          const radius = parseInt(this.elements.brushRadius.value) * (rect.width / (this.state.qrCode?.getModuleCount() || 1));
          this.elements.brushSilhouette.style.width = `${radius * 2}px`;
          this.elements.brushSilhouette.style.height = `${radius * 2}px`;
          this.elements.brushSilhouette.style.left = `${x - radius}px`;
          this.elements.brushSilhouette.style.top = `${y - radius}px`;
        }
        if (this.state.isBrushing) this.applyBrush(event);
      }

      startBrushing(event) {
        if (!this.state.brushEnabled || !this.state.qrCode) return;
        this.state.isBrushing = true;
        this.applyBrush(event);
      }

      stopBrushing() {
        if (this.state.isBrushing) {
          if (this.state.history.length > 10) this.state.history.shift();
          this.state.history.push(new Map(this.state.brushedModules));
          this.state.historyIndex = this.state.history.length - 1;
          this.state.isBrushing = false;
        }
      }

      applyBrush(event) {
        const rect = this.elements.qrCanvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = (event.clientY - rect.top) / rect.height;
        const n = this.state.qrCode.getModuleCount();
        const radius = parseInt(this.elements.brushRadius.value);
        const intensity = parseFloat(this.elements.brushIntensity.value);
        const minScale = parseFloat(this.elements.brushStrength.value);
        const maxTransparency = parseFloat(this.elements.brushTransparency.value);
        const rotationDelta = parseFloat(this.elements.rotationSpeed.value);
        const centerI = Math.floor(y * n);
        const centerJ = Math.floor(x * n);
        const maxDist = radius * radius;

        for (let di = -radius; di <= radius; di++) {
          for (let dj = -radius; dj <= radius; dj++) {
            const i = centerI + di;
            const j = centerJ + dj;
            if (i >= 0 && i < n && j >= 0 && j < n) {
              const dist = di * di + dj * dj;
              if (dist <= maxDist) {
                const key = `${i},${j}`;
                const current = this.state.brushedModules.get(key) || { scale: 1, transparency: 0, rotation: 0, sJitter: 0, lJitter: 0 };
                const feather = 1 - (dist / maxDist);
                const delta = intensity * feather;

                if (!this.elements.lockScale.checked) {
                  const targetScale = minScale;
                  const diff = targetScale - current.scale;
                  current.scale += diff * delta * Math.pow(feather, 2);
                  current.scale = Math.max(0.1, Math.min(1, current.scale));
                  if (this.elements.jitterScale.checked) {
                    current.scale *= 1 + (Math.random() - 0.5) * 0.1 * feather;
                    current.scale = Math.max(0.1, Math.min(1, current.scale));
                  }
                }

                if (!this.elements.lockTransparency.checked) {
                  current.transparency = Math.min(maxTransparency, current.transparency + delta);
                }

                if (!this.elements.lockRotation.checked && rotationDelta !== 0) {
                  current.rotation += rotationDelta * feather;
                  if (this.elements.jitterRotation.checked) {
                    current.rotation += (Math.random() - 0.5) * 10 * feather;
                  }
                }

                if (this.elements.jitterColor.checked && this.state.qrCode.isDark(i, j)) {
                  current.sJitter += delta * feather;
                  current.lJitter += delta * feather;
                  current.sJitter = Math.max(-0.5, Math.min(0.5, current.sJitter));
                  current.lJitter = Math.max(-0.5, Math.min(0.5, current.lJitter));
                }

                this.state.brushedModules.set(key, current);
              }
            }
          }
        }
        this.drawPreview();
      }

      resetRotation() {
        this.elements.rotationSpeed.value = 0;
        document.getElementById('rotation-speed-value').textContent = '0°';
        for (let [key, value] of this.state.brushedModules) {
          value.rotation = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetColors() {
        for (let [key, value] of this.state.brushedModules) {
          value.sJitter = 0;
          value.lJitter = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetScale() {
        for (let [key, value] of this.state.brushedModules) {
          value.scale = 1;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetTransparency() {
        for (let [key, value] of this.state.brushedModules) {
          value.transparency = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetAll() {
        this.state.brushedModules.clear();
        this.drawPreview();
      }

      undo() {
        if (this.state.historyIndex > 0) {
          this.state.historyIndex--;
          this.state.brushedModules = new Map(this.state.history[this.state.historyIndex]);
          this.drawPreview();
        }
      }

      redo() {
        if (this.state.historyIndex < this.state.history.length - 1) {
          this.state.historyIndex++;
          this.state.brushedModules = new Map(this.state.history[this.state.historyIndex]);
          this.drawPreview();
        }
      }

      downloadSVG() {
        const svg = this.generateSVG();
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'qr-code.svg';
        link.click();
        URL.revokeObjectURL(url);
      }

      generateSVG() {
        if (!this.state.qrCode) return '';
        const n = this.state.qrCode.getModuleCount();
        const moduleSize = 10;
        const svgSize = n * moduleSize;
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">`;

        if (this.state.logoSVGCode || this.state.logoImage.src) {
          const canvasSize = this.elements.previewContainer.clientWidth;
          const svgScaleFactor = svgSize / canvasSize;
          const logoWidth = this.state.logoBounds.width * svgScaleFactor;
          const logoHeight = this.state.logoBounds.height * svgScaleFactor;
          const x = this.state.logoBounds.x * svgScaleFactor;
          const y = this.state.logoBounds.y * svgScaleFactor;
          if (this.state.logoSVGCode) {
            const scaledLogoSVG = this.state.logoSVGCode.replace(/width="[^"]*"/, `width="${logoWidth}"`).replace(/height="[^"]*"/, `height="${logoHeight}"`);
            svg += `<svg x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}">${scaledLogoSVG}</svg>`;
          } else {
            svg += `<image href="${this.state.logoImage.src}" x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}"/>`;
          }
        }

        if (this.elements.smoothCorners.checked) {
          const roundness = parseFloat(this.elements.roundnessSlider.value);
          const outerRadius = roundness * (moduleSize * 3.5);
          const middleRadius = roundness * (moduleSize * 2.5);
          const innerRadius = roundness * (moduleSize * 1.5);
          svg += this.drawSVGRoundedPositionPattern(0, 0, moduleSize, outerRadius, middleRadius, innerRadius, this.state.blackColor, this.state.whiteColor);
          svg += this.drawSVGRoundedPositionPattern(0, n - 7, moduleSize, outerRadius, middleRadius, innerRadius, this.state.blackColor, this.state.whiteColor);
          svg += this.drawSVGRoundedPositionPattern(n - 7, 0, moduleSize, outerRadius, middleRadius, innerRadius, this.state.blackColor, this.state.whiteColor);
        }

        this.colorStrategy = this.elements.jitterColor.checked ? new JitterColorStrategy() : new DefaultColorStrategy();
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (this.elements.smoothCorners.checked && this.isPositionPattern(i, j, n)) continue;
            const { scale, transparency, rotation, sJitter, lJitter } = this.getModuleProperties(i, j);
            const size = moduleSize * scale;
            const offset = (moduleSize - size) / 2;
            const x = j * moduleSize + offset;
            const y = i * moduleSize + offset;
            const baseColor = this.state.qrCode.isDark(i, j) ? this.state.blackColor : this.state.whiteColor;
            const finalColor = this.colorStrategy.applyColor(baseColor, this.state.qrCode.isDark(i, j), sJitter, lJitter);
            const gradientId = `${i}_${j}_gradient`;
            svg += `<defs><radialGradient id="${gradientId}" cx="0.5" cy="0.5" r="0.5">
              <stop offset="0%" stop-color="${finalColor}" stop-opacity="1"/>
              <stop offset="100%" stop-color="${finalColor}" stop-opacity="${1 - transparency}"/>
            </radialGradient></defs>`;
            svg += `<rect x="${x}" y="${y}" width="${size}" height="${size}" fill="url(#${gradientId})" transform="rotate(${rotation}, ${x + size / 2}, ${y + size / 2})"/>`;
          }
        }
        svg += '</svg>';
        return svg;
      }

      drawSVGRoundedPositionPattern(row, col, moduleSize, outerRadius, middleRadius, innerRadius, blackColor, whiteColor) {
        const x = col * moduleSize;
        const y = row * moduleSize;
        return `
          <rect x="${x}" y="${y}" width="${7 * moduleSize}" height="${7 * moduleSize}" fill="${blackColor}" rx="${outerRadius}"/>
          <rect x="${x + moduleSize}" y="${y + moduleSize}" width="${5 * moduleSize}" height="${5 * moduleSize}" fill="${whiteColor}" rx="${middleRadius}"/>
          <rect x="${x + 2 * moduleSize}" y="${y + 2 * moduleSize}" width="${3 * moduleSize}" height="${3 * moduleSize}" fill="${blackColor}" rx="${innerRadius}"/>
        `;
      }
    }

    // Color Strategy Interface
    class ColorStrategy {
      applyColor(baseColor, isDark, sJitter, lJitter) {
        throw new Error('Method must be implemented');
      }
    }

    // Default Color Strategy
    class DefaultColorStrategy extends ColorStrategy {
      constructor() {
        super();
        this.qrGenerator = new QRCodeGenerator();
      }

      applyColor(baseColor, isDark, sJitter, lJitter) {
        return baseColor;
      }
    }

    // Jitter Color Strategy for Black Pixels (S and L only)
    class JitterColorStrategy extends ColorStrategy {
      constructor() {
        super();
        this.qrGenerator = new QRCodeGenerator();
      }

      applyColor(baseColor, isDark, sJitter, lJitter) {
        if (!isDark) return baseColor;
        const [h, s, l] = this.qrGenerator.rgbToHsl(...this.qrGenerator.hexToRgb(baseColor));
        const newS = Math.max(0, Math.min(1, s + sJitter));
        const newL = Math.max(0, Math.min(1, l + lJitter));
        const [r, g, b] = this.qrGenerator.hslToRgb(h, newS, newL);
        return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
      }
    }

    // Initialize the QR Code Generator
    new QRCodeGenerator();
  </script>
</body>
</html>
