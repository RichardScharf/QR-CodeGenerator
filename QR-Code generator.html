<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code Generator with Brush Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f0f0f0;
    }
    main {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    h1 {
      text-align: center;
      color: #333;
    }
    #preview-container {
      width: 100%;
      max-width: 500px;
      margin: 20px auto;
      position: relative;
    }
    #qr-canvas {
      width: 100%;
      height: auto;
      border: 1px solid #ddd;
    }
    #brush-silhouette {
      position: absolute;
      border: 1px dashed #000;
      border-radius: 50%;
      pointer-events: none;
      display: none;
    }
    .controls {
      display: grid;
      gap: 10px;
      margin-top: 20px;
    }
    label {
      margin-right: 10px;
      color: #555;
    }
    input[type="text"], select, button {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      background-color: #007BFF;
      color: white;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
    #upload-area {
      border: 2px dashed #ccc;
      padding: 20px;
      text-align: center;
      cursor: pointer;
    }
    #upload-area.dragover {
      background-color: #e0e0e0;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
  </style>
</head>
<body>
  <main>
    <h1>QR Code Generator with Brush Tool</h1>
    <div id="preview-container">
      <canvas id="qr-canvas"></canvas>
      <div id="brush-silhouette"></div>
    </div>
    <div class="controls">
      <div>
        <label for="qr-text">QR Text:</label>
        <input type="text" id="qr-text" value="https://example.com" placeholder="Enter text or URL">
      </div>
      <div>
        <label for="error-correction">Error Correction:</label>
        <select id="error-correction">
          <option value="L">Low</option>
          <option value="M" selected>Medium</option>
          <option value="Q">Quartile</option>
          <option value="H">High</option>
        </select>
      </div>
      <div>
        <label for="logo-upload">Upload Logo:</label>
        <input type="file" id="logo-upload" accept="image/*" style="display: none;">
        <div id="upload-area">Click or drag an image here</div>
      </div>
      <div class="slider-container">
        <label for="scale-slider">Logo Scale:</label>
        <input type="range" id="scale-slider" min="0.1" max="2" step="0.1" value="1">
        <span id="scale-slider-value">1</span>
      </div>
      <div>
        <label><input type="checkbox" id="smooth-corners"> Smooth Corners</label>
      </div>
      <div class="slider-container">
        <label for="roundness">Roundness:</label>
        <input type="range" id="roundness" min="0" max="1" step="0.1" value="0.5">
        <span id="roundness-value">0.5</span>
      </div>
      <div>
        <label for="black-color-picker">Black Color:</label>
        <input type="color" id="black-color-picker" value="#000000">
      </div>
      <div>
        <label for="white-color-picker">White Color:</label>
        <input type="color" id="white-color-picker" value="#FFFFFF">
      </div>
      <div>
        <button id="brush-toggle">Enable Brush</button>
      </div>
      <div class="slider-container">
        <label for="brush-radius">Brush Radius:</label>
        <input type="range" id="brush-radius" min="1" max="10" value="3">
        <span id="brush-radius-value">3</span>
      </div>
      <div class="slider-container">
        <label for="brush-strength">Brush Strength:</label>
        <input type="range" id="brush-strength" min="0" max="1" step="0.1" value="0.5">
        <span id="brush-strength-value">0.5</span>
      </div>
      <div class="slider-container">
        <label for="brush-intensity">Brush Intensity:</label>
        <input type="range" id="brush-intensity" min="0" max="1" step="0.1" value="0.5">
        <span id="brush-intensity-value">0.5</span>
      </div>
      <div class="slider-container">
        <label for="brush-transparency">Brush Transparency:</label>
        <input type="range" id="brush-transparency" min="0" max="1" step="0.1" value="0.5">
        <span id="brush-transparency-value">0.5</span>
      </div>
      <div class="slider-container">
        <label for="rotation-speed">Rotation Speed:</label>
        <input type="range" id="rotation-speed" min="-45" max="45" value="0">
        <span id="rotation-speed-value">0°</span>
      </div>
      <div>
        <label><input type="checkbox" id="lock-scale"> Lock Scale</label>
        <label><input type="checkbox" id="lock-rotation"> Lock Rotation</label>
        <label><input type="checkbox" id="lock-transparency"> Lock Transparency</label>
      </div>
      <div>
        <label><input type="checkbox" id="jitter-scale"> Jitter Scale</label>
        <label><input type="checkbox" id="jitter-rotation"> Jitter Rotation</label>
        <label><input type="checkbox" id="jitter-color"> Jitter Color</label>
      </div>
      <div>
        <button id="reset-rotation-btn">Reset Rotation</button>
        <button id="reset-colors-btn">Reset Colors</button>
        <button id="reset-scale-btn">Reset Scale</button>
        <button id="reset-transparency-btn">Reset Transparency</button>
        <button id="reset-all-btn">Reset All</button>
      </div>
      <div>
        <button id="undo-btn">Undo</button>
        <button id="redo-btn">Redo</button>
      </div>
      <div>
        <button id="download-btn">Download SVG</button>
      </div>
    </div>
  </main>
  <script>
    // --- Utility Functions ---
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return [r, g, b];
    }

    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [h, s, l];
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // --- Brush Command for Undo/Redo ---
    class BrushCommand {
      constructor(modules) {
        this.previousModules = new Map([...modules]);
      }
      apply(qrGenerator) {
        qrGenerator.state.brushedModules = new Map([...this.previousModules]);
        qrGenerator.drawPreview();
      }
    }

    // --- Command History Manager ---
    class CommandHistory {
      constructor() {
        this.undoStack = [];
        this.redoStack = [];
      }
      add(command) {
        this.undoStack.push(command);
        this.redoStack = [];
      }
      undo(qrGenerator) {
        const command = this.undoStack.pop();
        if (command) {
          this.redoStack.push(new BrushCommand(qrGenerator.state.brushedModules));
          command.apply(qrGenerator);
        }
      }
      redo(qrGenerator) {
        const command = this.redoStack.pop();
        if (command) {
          this.undoStack.push(new BrushCommand(qrGenerator.state.brushedModules));
          command.apply(qrGenerator);
        }
      }
      clear() {
        this.undoStack = [];
        this.redoStack = [];
      }
    }

    // --- QR Code Generator Class ---
    class QRCodeGenerator {
      constructor() {
        // DOM Elements
        this.elements = {
          qrText: document.getElementById('qr-text'),
          logoUpload: document.getElementById('logo-upload'),
          scaleSlider: document.getElementById('scale-slider'),
          errorCorrection: document.getElementById('error-correction'),
          smoothCorners: document.getElementById('smooth-corners'),
          roundnessSlider: document.getElementById('roundness'),
          brushRadius: document.getElementById('brush-radius'),
          brushStrength: document.getElementById('brush-strength'),
          brushIntensity: document.getElementById('brush-intensity'),
          brushTransparency: document.getElementById('brush-transparency'),
          rotationSpeed: document.getElementById('rotation-speed'),
          lockScale: document.getElementById('lock-scale'),
          lockRotation: document.getElementById('lock-rotation'),
          lockTransparency: document.getElementById('lock-transparency'),
          jitterScale: document.getElementById('jitter-scale'),
          jitterRotation: document.getElementById('jitter-rotation'),
          jitterColor: document.getElementById('jitter-color'),
          blackColorPicker: document.getElementById('black-color-picker'),
          whiteColorPicker: document.getElementById('white-color-picker'),
          brushToggle: document.getElementById('brush-toggle'),
          resetRotationBtn: document.getElementById('reset-rotation-btn'),
          resetColorsBtn: document.getElementById('reset-colors-btn'),
          resetScaleBtn: document.getElementById('reset-scale-btn'),
          resetTransparencyBtn: document.getElementById('reset-transparency-btn'),
          resetAllBtn: document.getElementById('reset-all-btn'),
          undoBtn: document.getElementById('undo-btn'),
          redoBtn: document.getElementById('redo-btn'),
          previewContainer: document.getElementById('preview-container'),
          uploadArea: document.getElementById('upload-area'),
          downloadBtn: document.getElementById('download-btn'),
          qrCanvas: document.getElementById('qr-canvas'),
          brushSilhouette: document.getElementById('brush-silhouette'),
          ctx: document.getElementById('qr-canvas').getContext('2d')
        };

        // State Management
        this.state = {
          logoImage: new Image(),
          logoScale: 1,
          qrCode: null,
          logoBounds: null,
          logoSVGCode: null,
          brushedModules: new Map(),
          isBrushing: false,
          brushEnabled: false,
          blackColor: '#000000',
          whiteColor: '#FFFFFF'
        };

        // History for Undo/Redo
        this.history = new CommandHistory();

        // Setup Event Listeners
        this.setupEventListeners();
        this.generateQRCode();
      }

      setupEventListeners() {
        const sliders = [
          { el: this.elements.scaleSlider, display: 'scale-slider-value', format: v => v },
          { el: this.elements.brushRadius, display: 'brush-radius-value', format: v => v },
          { el: this.elements.brushStrength, display: 'brush-strength-value', format: v => v },
          { el: this.elements.brushIntensity, display: 'brush-intensity-value', format: v => v },
          { el: this.elements.brushTransparency, display: 'brush-transparency-value', format: v => v },
          { el: this.elements.rotationSpeed, display: 'rotation-speed-value', format: v => `${v}°` },
          { el: this.elements.roundnessSlider, display: 'roundness-value', format: v => v }
        ];
        sliders.forEach(slider => {
          slider.el.addEventListener('input', () => {
            document.getElementById(slider.display).textContent = slider.format(slider.el.value);
            if (slider.el === this.elements.scaleSlider) {
              this.state.logoScale = parseFloat(slider.el.value);
              this.updateLogoBounds();
            }
            this.drawPreview();
          });
        });

        this.elements.blackColorPicker.addEventListener('input', () => {
          this.state.blackColor = this.elements.blackColorPicker.value;
          this.drawPreview();
        });
        this.elements.whiteColorPicker.addEventListener('input', () => {
          this.state.whiteColor = this.elements.whiteColorPicker.value;
          this.drawPreview();
        });

        this.elements.qrText.addEventListener('input', () => this.generateQRCode());
        this.elements.errorCorrection.addEventListener('change', () => this.generateQRCode());
        this.elements.smoothCorners.addEventListener('change', () => this.drawPreview());
        this.elements.jitterColor.addEventListener('change', () => this.drawPreview());

        this.elements.brushToggle.addEventListener('click', () => this.toggleBrush());
        this.elements.qrCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.elements.qrCanvas.addEventListener('mousedown', (e) => this.startBrushing(e));
        this.elements.qrCanvas.addEventListener('mouseup', () => this.stopBrushing());

        this.elements.resetRotationBtn.addEventListener('click', () => this.resetRotation());
        this.elements.resetColorsBtn.addEventListener('click', () => this.resetColors());
        this.elements.resetScaleBtn.addEventListener('click', () => this.resetScale());
        this.elements.resetTransparencyBtn.addEventListener('click', () => this.resetTransparency());
        this.elements.resetAllBtn.addEventListener('click', () => this.resetAll());

        this.elements.undoBtn.addEventListener('click', () => this.history.undo(this));
        this.elements.redoBtn.addEventListener('click', () => this.history.redo(this));

        this.elements.downloadBtn.addEventListener('click', () => this.downloadSVG());

        this.elements.uploadArea.addEventListener('click', () => this.elements.logoUpload.click());
        this.elements.logoUpload.addEventListener('change', (e) => this.loadLogo(e.target.files[0]));
        this.elements.uploadArea.addEventListener('dragover', (e) => {
          e.preventDefault();
          this.elements.uploadArea.classList.add('dragover');
        });
        this.elements.uploadArea.addEventListener('dragleave', () => {
          this.elements.uploadArea.classList.remove('dragover');
        });
        this.elements.uploadArea.addEventListener('drop', (e) => {
          e.preventDefault();
          this.elements.uploadArea.classList.remove('dragover');
          const file = e.dataTransfer.files[0];
          if (file && file.type.startsWith('image/')) this.loadLogo(file);
        });
      }

      loadLogo(file) {
        const reader = new FileReader();
        if (file.type === 'image/svg+xml') {
          reader.onload = (e) => {
            let svgContent = e.target.result.replace(/<\?xml[^>]*\?>/, '').replace(/<!DOCTYPE[^>]*>/, '');
            this.state.logoSVGCode = svgContent;
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            this.state.logoImage.src = URL.createObjectURL(blob);
            this.state.logoImage.onload = () => {
              this.updateLogoBounds();
              this.drawPreview();
            };
          };
          reader.readAsText(file);
        } else {
          reader.onload = (e) => {
            this.state.logoImage.src = e.target.result;
            this.state.logoImage.onload = () => {
              this.updateLogoBounds();
              this.drawPreview();
            };
          };
          reader.readAsDataURL(file);
        }
      }

      updateLogoBounds() {
        if (!this.state.logoImage.src) return;
        const canvasSize = this.elements.previewContainer.clientWidth;
        const logoWidth = this.state.logoImage.width * this.state.logoScale;
        const logoHeight = this.state.logoImage.height * this.state.logoScale;
        this.state.logoBounds = {
          x: (canvasSize - logoWidth) / 2,
          y: (canvasSize - logoHeight) / 2,
          width: logoWidth,
          height: logoHeight
        };
      }

      generateQRCode() {
        if (this.elements.qrText.value) {
          this.state.qrCode = qrcode(0, this.elements.errorCorrection.value);
          this.state.qrCode.addData(this.elements.qrText.value);
          this.state.qrCode.make();
          this.state.brushedModules.clear();
          this.history.clear();
          this.drawPreview();
        } else {
          this.state.qrCode = null;
          this.drawPreview();
        }
      }

      getModuleProperties(i, j) {
        const key = `${i},${j}`;
        return this.state.brushedModules.get(key) || { scale: 1, transparency: 0, rotation: 0, sShift: 0, lShift: 0 };
      }

      applyColorJitter(baseColor, sShift, lShift) {
        const [r, g, b] = hexToRgb(baseColor);
        const [h, s, l] = rgbToHsl(r, g, b);
        const newS = Math.min(1, Math.max(0, s + sShift));
        const newL = Math.min(1, Math.max(0, l + lShift));
        const [newR, newG, newB] = hslToRgb(h, newS, newL);
        return `rgb(${newR},${newG},${newB})`;
      }

      drawPreview() {
        const canvasSize = this.elements.previewContainer.clientWidth;
        this.elements.qrCanvas.width = canvasSize;
        this.elements.qrCanvas.height = canvasSize;
        this.elements.ctx.clearRect(0, 0, canvasSize, canvasSize);

        if (this.state.logoImage.src) {
          this.elements.ctx.drawImage(this.state.logoImage, this.state.logoBounds.x, this.state.logoBounds.y, this.state.logoBounds.width, this.state.logoBounds.height);
        }

        if (!this.state.qrCode) return;

        const n = this.state.qrCode.getModuleCount();
        const moduleSize = canvasSize / n;

        if (this.elements.smoothCorners.checked) {
          const roundness = parseFloat(this.elements.roundnessSlider.value);
          this.drawPositionPatternCanvas(0, 0, moduleSize, roundness);
          this.drawPositionPatternCanvas(0, n - 7, moduleSize, roundness);
          this.drawPositionPatternCanvas(n - 7, 0, moduleSize, roundness);
        }

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            const { scale, transparency, rotation, sShift, lShift } = this.getModuleProperties(i, j);
            const size = moduleSize * scale;
            const offset = (moduleSize - size) / 2;
            const x = j * moduleSize + offset;
            const y = i * moduleSize + offset;
            const centerX = x + size / 2;
            const centerY = y + size / 2;
            let baseColor = this.state.qrCode.isDark(i, j) ? this.state.blackColor : this.state.whiteColor;
            const finalColor = this.state.qrCode.isDark(i, j) ? this.applyColorJitter(baseColor, sShift, lShift) : baseColor;
            const gradient = this.elements.ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
            gradient.addColorStop(0, finalColor);
            gradient.addColorStop(1, `rgba(${hexToRgb(finalColor).join(',')},${1 - transparency})`);
            this.elements.ctx.save();
            this.elements.ctx.translate(centerX, centerY);
            this.elements.ctx.rotate(rotation * Math.PI / 180);
            this.elements.ctx.translate(-centerX, -centerY);
            this.elements.ctx.fillStyle = gradient;
            this.elements.ctx.fillRect(x, y, size, size);
            this.elements.ctx.restore();
          }
        }
      }

      drawPositionPatternCanvas(row, col, moduleSize, roundness) {
        const x = col * moduleSize;
        const y = row * moduleSize;
        const outerRadius = roundness * (moduleSize * 3.5);
        const middleRadius = roundness * (moduleSize * 2.5);
        const innerRadius = roundness * (moduleSize * 1.5);
        this.elements.ctx.fillStyle = this.state.blackColor;
        this.drawRoundedRect(x, y, 7 * moduleSize, 7 * moduleSize, outerRadius);
        this.elements.ctx.fillStyle = this.state.whiteColor;
        this.drawRoundedRect(x + moduleSize, y + moduleSize, 5 * moduleSize, 5 * moduleSize, middleRadius);
        this.elements.ctx.fillStyle = this.state.blackColor;
        this.drawRoundedRect(x + 2 * moduleSize, y + 2 * moduleSize, 3 * moduleSize, 3 * moduleSize, innerRadius);
      }

      drawRoundedRect(x, y, width, height, radius) {
        this.elements.ctx.beginPath();
        this.elements.ctx.moveTo(x + radius, y);
        this.elements.ctx.lineTo(x + width - radius, y);
        this.elements.ctx.arcTo(x + width, y, x + width, y + radius, radius);
        this.elements.ctx.lineTo(x + width, y + height - radius);
        this.elements.ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
        this.elements.ctx.lineTo(x + radius, y + height);
        this.elements.ctx.arcTo(x, y + height, x, y + height - radius, radius);
        this.elements.ctx.lineTo(x, y + radius);
        this.elements.ctx.arcTo(x, y, x + radius, y, radius);
        this.elements.ctx.closePath();
        this.elements.ctx.fill();
      }

      toggleBrush() {
        this.state.brushEnabled = !this.state.brushEnabled;
        this.elements.brushToggle.textContent = this.state.brushEnabled ? 'Disable Brush' : 'Enable Brush';
        this.elements.qrCanvas.style.cursor = this.state.brushEnabled ? 'crosshair' : 'default';
        this.elements.brushSilhouette.style.display = this.state.brushEnabled ? 'block' : 'none';
      }

      handleMouseMove(event) {
        if (!this.state.brushEnabled) return;
        const rect = this.elements.qrCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const radius = parseInt(this.elements.brushRadius.value) * (rect.width / (this.state.qrCode?.getModuleCount() || 1));
        this.elements.brushSilhouette.style.width = `${radius * 2}px`;
        this.elements.brushSilhouette.style.height = `${radius * 2}px`;
        this.elements.brushSilhouette.style.left = `${x - radius}px`;
        this.elements.brushSilhouette.style.top = `${y - radius}px`;
        if (this.state.isBrushing) this.applyBrush(event);
      }

      startBrushing(event) {
        if (!this.state.brushEnabled || !this.state.qrCode) return;
        this.state.isBrushing = true;
        this.history.add(new BrushCommand(this.state.brushedModules));
        this.applyBrush(event);
      }

      stopBrushing() {
        this.state.isBrushing = false;
      }

      applyBrush(event) {
        const rect = this.elements.qrCanvas.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = (event.clientY - rect.top) / rect.height;
        const n = this.state.qrCode.getModuleCount();
        const radius = parseInt(this.elements.brushRadius.value);
        const intensity = parseFloat(this.elements.brushIntensity.value);
        const minScale = parseFloat(this.elements.brushStrength.value);
        const maxTransparency = parseFloat(this.elements.brushTransparency.value);
        const rotationDelta = parseFloat(this.elements.rotationSpeed.value);
        const centerI = Math.floor(y * n);
        const centerJ = Math.floor(x * n);
        const maxDist = radius * radius;

        for (let di = -radius; di <= radius; di++) {
          for (let dj = -radius; dj <= radius; dj++) {
            const i = centerI + di;
            const j = centerJ + dj;
            if (i >= 0 && i < n && j >= 0 && j < n) {
              const dist = di * di + dj * dj;
              if (dist <= maxDist) {
                const key = `${i},${j}`;
                const current = this.getModuleProperties(i, j);
                const feather = 1 - (dist / maxDist);
                const delta = intensity * feather;

                if (!this.elements.lockScale.checked) {
                  const targetScale = minScale;
                  const diff = targetScale - current.scale;
                  current.scale += diff * delta * Math.pow(feather, 2);
                  current.scale = Math.max(0.1, Math.min(1, current.scale));
                  if (this.elements.jitterScale.checked) {
                    current.scale *= 1 + (Math.random() - 0.5) * 0.1 * feather;
                    current.scale = Math.max(0.1, Math.min(1, current.scale));
                  }
                }

                if (!this.elements.lockTransparency.checked) {
                  current.transparency = Math.min(maxTransparency, current.transparency + delta);
                }

                if (!this.elements.lockRotation.checked && rotationDelta !== 0) {
                  current.rotation += rotationDelta * feather;
                  if (this.elements.jitterRotation.checked) {
                    current.rotation += (Math.random() - 0.5) * 10 * feather;
                  }
                }

                if (this.elements.jitterColor.checked && this.state.qrCode.isDark(i, j)) {
                  current.sShift += (Math.random() - 0.5) * 0.2 * delta;
                  current.lShift += (Math.random() - 0.5) * 0.2 * delta;
                  current.sShift = Math.max(-0.5, Math.min(0.5, current.sShift));
                  current.lShift = Math.max(-0.5, Math.min(0.5, current.lShift));
                }

                this.state.brushedModules.set(key, current);
              }
            }
          }
        }
        this.drawPreview();
      }

      resetRotation() {
        this.elements.rotationSpeed.value = 0;
        document.getElementById('rotation-speed-value').textContent = '0°';
        for (let [key, value] of this.state.brushedModules) {
          value.rotation = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetColors() {
        for (let [key, value] of this.state.brushedModules) {
          value.sShift = 0;
          value.lShift = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetScale() {
        for (let [key, value] of this.state.brushedModules) {
          value.scale = 1;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetTransparency() {
        for (let [key, value] of this.state.brushedModules) {
          value.transparency = 0;
          this.state.brushedModules.set(key, value);
        }
        this.drawPreview();
      }

      resetAll() {
        this.state.brushedModules.clear();
        this.drawPreview();
      }

      downloadSVG() {
        const svg = this.generateSVG();
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'qr-code.svg';
        link.click();
        URL.revokeObjectURL(url);
      }

      generateSVG() {
        if (!this.state.qrCode) return '';
        const n = this.state.qrCode.getModuleCount();
        const moduleSize = 10;
        const svgSize = n * moduleSize;
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">`;

        if (this.state.logoSVGCode || this.state.logoImage.src) {
          const canvasSize = this.elements.previewContainer.clientWidth;
          const svgScaleFactor = svgSize / canvasSize;
          const logoWidth = this.state.logoBounds.width * svgScaleFactor;
          const logoHeight = this.state.logoBounds.height * svgScaleFactor;
          const x = this.state.logoBounds.x * svgScaleFactor;
          const y = this.state.logoBounds.y * svgScaleFactor;
          if (this.state.logoSVGCode) {
            const scaledLogoSVG = this.state.logoSVGCode.replace(/width="[^"]*"/, `width="${logoWidth}"`).replace(/height="[^"]*"/, `height="${logoHeight}"`);
            svg += `<svg x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}">${scaledLogoSVG}</svg>`;
          } else {
            svg += `<image href="${this.state.logoImage.src}" x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}"/>`;
          }
        }

        if (this.elements.smoothCorners.checked) {
          const roundness = parseFloat(this.elements.roundnessSlider.value);
          const outerRadius = roundness * (moduleSize * 3.5);
          const middleRadius = roundness * (moduleSize * 2.5);
          const innerRadius = roundness * (moduleSize * 1.5);
          svg += this.drawSVGRoundedPositionPattern(0, 0, moduleSize, outerRadius, middleRadius, innerRadius);
          svg += this.drawSVGRoundedPositionPattern(0, n - 7, moduleSize, outerRadius, middleRadius, innerRadius);
          svg += this.drawSVGRoundedPositionPattern(n - 7, 0, moduleSize, outerRadius, middleRadius, innerRadius);
        }

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (this.elements.smoothCorners.checked && this.isPositionPattern(i, j, n)) continue;
            const { scale, transparency, rotation, sShift, lShift } = this.getModuleProperties(i, j);
            const size = moduleSize * scale;
            const offset = (moduleSize - size) / 2;
            const x = j * moduleSize + offset;
            const y = i * moduleSize + offset;
            let baseColor = this.state.qrCode.isDark(i, j) ? this.state.blackColor : this.state.whiteColor;
            const finalColor = this.state.qrCode.isDark(i, j) ? this.applyColorJitter(baseColor, sShift, lShift) : baseColor;
            const gradientId = `${i}_${j}_gradient`;
            svg += `<defs><radialGradient id="${gradientId}" cx="0.5" cy="0.5" r="0.5">
              <stop offset="0%" stop-color="${finalColor}" stop-opacity="1"/>
              <stop offset="100%" stop-color="${finalColor}" stop-opacity="${1 - transparency}"/>
            </radialGradient></defs>`;
            svg += `<rect x="${x}" y="${y}" width="${size}" height="${size}" fill="url(#${gradientId})" transform="rotate(${rotation}, ${x + size / 2}, ${y + size / 2})"/>`;
          }
        }
        svg += '</svg>';
        return svg;
      }

      drawSVGRoundedPositionPattern(row, col, moduleSize, outerRadius, middleRadius, innerRadius) {
        const x = col * moduleSize;
        const y = row * moduleSize;
        return `
          <rect x="${x}" y="${y}" width="${7 * moduleSize}" height="${7 * moduleSize}" fill="${this.state.blackColor}" rx="${outerRadius}"/>
          <rect x="${x + moduleSize}" y="${y + moduleSize}" width="${5 * moduleSize}" height="${5 * moduleSize}" fill="${this.state.whiteColor}" rx="${middleRadius}"/>
          <rect x="${x + 2 * moduleSize}" y="${y + 2 * moduleSize}" width="${3 * moduleSize}" height="${3 * moduleSize}" fill="${this.state.blackColor}" rx="${innerRadius}"/>
        `;
      }

      isPositionPattern(i, j, n) {
        return (i < 7 && j < 7) || (i < 7 && j >= n - 7) || (i >= n - 7 && j < 7);
      }
    }

    // --- Initialize ---
    new QRCodeGenerator();
  </script>
</body>
</html>
