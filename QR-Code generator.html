<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code Generator with Brush Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
      color: #333;
    }
    main {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      padding: 20px;
      width: 90%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    #qr-text {
      width: 100%;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 16px;
    }
    #upload-area {
      border: 2px dashed #aaa;
      padding: 20px;
      text-align: center;
      background: #fafafa;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #upload-area.dragover {
      background: #e0e0e0;
    }
    #preview-container {
      position: relative;
      width: 100%;
      max-width: 300px;
      height: 300px;
      border: 1px solid #ddd;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      align-self: center;
    }
    #qr-canvas {
      width: 100%;
      height: 100%;
    }
    #brush-silhouette {
      position: absolute;
      pointer-events: none;
      border: 1px dashed #666;
      border-radius: 50%;
      display: none;
    }
    #controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .section {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #eee;
    }
    .section-title {
      font-weight: 600;
      margin-bottom: 10px;
      font-size: 16px;
      color: #555;
    }
    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .control-group label {
      font-size: 14px;
      margin-bottom: 5px;
      color: #666;
    }
    input[type="range"], select, input[type="color"] {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
    }
    button {
      padding: 10px 20px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    .checkbox-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .slider-value {
      font-size: 12px;
      color: #777;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <main>
    <input type="text" id="qr-text" placeholder="Enter text for QR code">
    <div id="upload-area">
      <p>Drag or click to upload logo (PNG, JPG, SVG)</p>
      <input type="file" id="logo-upload" accept="image/*" style="display: none;">
    </div>
    <div id="controls">
      <div class="section">
        <div class="section-title">QR Code Settings</div>
        <div class="control-grid">
          <div class="control-group">
            <label for="scale-slider">Logo Scale: <span class="slider-value" id="scale-slider-value">1.0</span></label>
            <input type="range" id="scale-slider" min="0.1" max="2" step="0.1" value="1">
          </div>
          <div class="control-group">
            <label for="error-correction">Error Correction</label>
            <select id="error-correction">
              <option value="L">L (7%)</option>
              <option value="M" selected>M (15%)</option>
              <option value="Q">Q (25%)</option>
              <option value="H">H (30%)</option>
            </select>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="smooth-corners">
            <label for="smooth-corners">Smooth Corners</label>
          </div>
          <div class="control-group">
            <label for="roundness">Corner Roundness: <span class="slider-value" id="roundness-value">0.5</span></label>
            <input type="range" id="roundness" min="0" max="1" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="black-color-picker">Black Pixel Color</label>
            <input type="color" id="black-color-picker" value="#000000">
          </div>
          <div class="control-group">
            <label for="white-color-picker">White Pixel Color</label>
            <input type="color" id="white-color-picker" value="#FFFFFF">
          </div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Brush Tool</div>
        <div class="control-grid">
          <div class="control-group">
            <label for="brush-radius">Brush Radius: <span class="slider-value" id="brush-radius-value">3</span></label>
            <input type="range" id="brush-radius" min="1" max="10" step="1" value="3">
          </div>
          <div class="control-group">
            <label for="brush-strength">Strength (Min Size): <span class="slider-value" id="brush-strength-value">0.5</span></label>
            <input type="range" id="brush-strength" min="0.1" max="1.0" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="brush-intensity">Intensity/Speed: <span class="slider-value" id="brush-intensity-value">0.05</span></label>
            <input type="range" id="brush-intensity" min="0.01" max="0.1" step="0.01" value="0.05">
          </div>
          <div class="control-group">
            <label for="brush-transparency">Max Transparency: <span class="slider-value" id="brush-transparency-value">0.5</span></label>
            <input type="range" id="brush-transparency" min="0.0" max="1.0" step="0.1" value="0.5">
          </div>
          <div class="control-group">
            <label for="rotation-speed">Rotation Speed: <span class="slider-value" id="rotation-speed-value">0°</span></label>
            <input type="range" id="rotation-speed" min="-0.5" max="0.5" step="0.05" value="0">
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-scale">
            <label for="lock-scale">Lock Scale</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-rotation">
            <label for="lock-rotation">Lock Rotation</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="lock-transparency">
            <label for="lock-transparency">Lock Transparency</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-scale">
            <label for="jitter-scale">Jitter Scale</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-rotation">
            <label for="jitter-rotation">Jitter Rotation</label>
          </div>
          <div class="control-group checkbox-group">
            <input type="checkbox" id="jitter-color">
            <label for="jitter-color">Jitter Color</label>
          </div>
        </div>
        <div class="button-group">
          <button id="brush-toggle">Enable Brush</button>
          <button id="reset-rotation-btn">Reset Rotation</button>
          <button id="reset-colors-btn">Reset Colors</button>
          <button id="reset-scale-btn">Reset Scale</button>
          <button id="reset-transparency-btn">Reset Transparency</button>
          <button id="reset-all-btn">Reset All</button>
          <button id="undo-btn">Undo</button>
          <button id="redo-btn">Redo</button>
        </div>
      </div>
    </div>
    <div id="preview-container">
      <canvas id="qr-canvas"></canvas>
      <div id="brush-silhouette"></div>
    </div>
    <button id="download-btn">Download QR Code (SVG)</button>
  </main>
  <script>
    const qrText = document.getElementById('qr-text');
    const logoUpload = document.getElementById('logo-upload');
    const scaleSlider = document.getElementById('scale-slider');
    const errorCorrection = document.getElementById('error-correction');
    const smoothCorners = document.getElementById('smooth-corners');
    const roundnessSlider = document.getElementById('roundness');
    const brushRadius = document.getElementById('brush-radius');
    const brushStrength = document.getElementById('brush-strength');
    const brushIntensity = document.getElementById('brush-intensity');
    const brushTransparency = document.getElementById('brush-transparency');
    const rotationSpeed = document.getElementById('rotation-speed');
    const lockScale = document.getElementById('lock-scale');
    const lockRotation = document.getElementById('lock-rotation');
    const lockTransparency = document.getElementById('lock-transparency');
    const jitterScale = document.getElementById('jitter-scale');
    const jitterRotation = document.getElementById('jitter-rotation');
    const jitterColor = document.getElementById('jitter-color');
    const blackColorPicker = document.getElementById('black-color-picker');
    const whiteColorPicker = document.getElementById('white-color-picker');
    const brushToggle = document.getElementById('brush-toggle');
    const resetRotationBtn = document.getElementById('reset-rotation-btn');
    const resetColorsBtn = document.getElementById('reset-colors-btn');
    const resetScaleBtn = document.getElementById('reset-scale-btn');
    const resetTransparencyBtn = document.getElementById('reset-transparency-btn');
    const resetAllBtn = document.getElementById('reset-all-btn');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const previewContainer = document.getElementById('preview-container');
    const uploadArea = document.getElementById('upload-area');
    const downloadBtn = document.getElementById('download-btn');
    const qrCanvas = document.getElementById('qr-canvas');
    const brushSilhouette = document.getElementById('brush-silhouette');
    const ctx = qrCanvas.getContext('2d');

    let logoImage = new Image();
    let logoScale = 1;
    let qrCode = null;
    let logoBounds = null;
    let logoSVGCode = null;
    let brushedModules = new Map();
    let history = [];
    let historyIndex = -1;
    let isBrushing = false;
    let brushEnabled = false;
    let blackColor = '#000000';
    let whiteColor = '#FFFFFF';

    // Consolidated slider and input event listeners
    const sliders = [
      { el: scaleSlider, display: 'scale-slider-value', format: v => v },
      { el: brushRadius, display: 'brush-radius-value', format: v => v },
      { el: brushStrength, display: 'brush-strength-value', format: v => v },
      { el: brushIntensity, display: 'brush-intensity-value', format: v => v },
      { el: brushTransparency, display: 'brush-transparency-value', format: v => v },
      { el: rotationSpeed, display: 'rotation-speed-value', format: v => `${v}°` },
      { el: roundnessSlider, display: 'roundness-value', format: v => v }
    ];
    sliders.forEach(slider => {
      slider.el.addEventListener('input', () => {
        document.getElementById(slider.display).textContent = slider.format(slider.el.value);
        if (slider.el === scaleSlider) {
          logoScale = parseFloat(slider.el.value);
          updateLogoBounds();
        }
        drawPreview();
      });
    });

    blackColorPicker.addEventListener('input', () => { blackColor = blackColorPicker.value; drawPreview(); });
    whiteColorPicker.addEventListener('input', () => { whiteColor = whiteColorPicker.value; drawPreview(); });

    uploadArea.addEventListener('click', () => logoUpload.click());
    logoUpload.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) loadLogo(file);
    });
    uploadArea.addEventListener('dragover', (event) => {
      event.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
    uploadArea.addEventListener('drop', (event) => {
      event.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = event.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) loadLogo(file);
    });

    function loadLogo(file) {
      const reader = new FileReader();
      if (file.type === 'image/svg+xml') {
        reader.onload = (e) => {
          let svgContent = e.target.result.replace(/<\?xml[^>]*\?>/, '').replace(/<!DOCTYPE[^>]*>/, '');
          logoSVGCode = svgContent;
          const blob = new Blob([svgContent], { type: 'image/svg+xml' });
          logoImage.src = URL.createObjectURL(blob);
          logoImage.onload = () => { updateLogoBounds(); drawPreview(); };
        };
        reader.readAsText(file);
      } else {
        reader.onload = (e) => {
          logoImage.src = e.target.result;
          logoImage.onload = () => { updateLogoBounds(); drawPreview(); };
        };
        reader.readAsDataURL(file);
      }
    }

    function updateLogoBounds() {
      if (!logoImage.src) return;
      const canvasSize = previewContainer.clientWidth;
      const logoWidth = logoImage.width * logoScale;
      const logoHeight = logoImage.height * logoScale;
      logoBounds = {
        x: (canvasSize - logoWidth) / 2,
        y: (canvasSize - logoHeight) / 2,
        width: logoWidth,
        height: logoHeight
      };
    }

    function generateQRCode() {
      if (qrText.value) {
        qrCode = qrcode(0, errorCorrection.value);
        qrCode.addData(qrText.value);
        qrCode.make();
        brushedModules.clear();
        history = [];
        historyIndex = -1;
        drawPreview();
      } else {
        qrCode = null;
        drawPreview();
      }
    }
    qrText.addEventListener('input', generateQRCode);
    errorCorrection.addEventListener('change', generateQRCode);
    smoothCorners.addEventListener('change', drawPreview);

    function getModuleProperties(i, j) {
      const key = `${i},${j}`;
      return brushedModules.get(key) || { scale: 1, transparency: 0, rotation: 0, colorOffset: 0 };
    }

    function drawPreview() {
      const canvasSize = previewContainer.clientWidth;
      qrCanvas.width = canvasSize;
      qrCanvas.height = canvasSize;
      ctx.clearRect(0, 0, canvasSize, canvasSize);

      if (logoImage.src) {
        ctx.drawImage(logoImage, logoBounds.x, logoBounds.y, logoBounds.width, logoBounds.height);
      }

      if (qrCode) {
        const n = qrCode.getModuleCount();
        const moduleSize = canvasSize / n;

        if (smoothCorners.checked) {
          const roundness = parseFloat(roundnessSlider.value);
          drawPositionPatternCanvas(0, 0, moduleSize, roundness, blackColor, whiteColor);
          drawPositionPatternCanvas(0, n - 7, moduleSize, roundness, blackColor, whiteColor);
          drawPositionPatternCanvas(n - 7, 0, moduleSize, roundness, blackColor, whiteColor);
        }

        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (smoothCorners.checked && isPositionPattern(i, j, n)) continue;
            const { scale, transparency, rotation, colorOffset } = getModuleProperties(i, j);
            const size = moduleSize * scale;
            const offset = (moduleSize - size) / 2;
            const x = j * moduleSize + offset;
            const y = i * moduleSize + offset;
            const centerX = x + size / 2;
            const centerY = y + size / 2;
            const baseColor = qrCode.isDark(i, j) ? blackColor : whiteColor;
            const jitteredColor = applyColorJitter(baseColor, colorOffset);
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size / 2);
            gradient.addColorStop(0, jitteredColor);
            gradient.addColorStop(1, `rgba(${hexToRgb(jitteredColor).join(',')},${1 - transparency})`);
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.translate(-centerX, -centerY);
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, size, size);
            ctx.restore();
          }
        }
      }
    }

    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return [r, g, b];
    }

    function applyColorJitter(baseColor, offset) {
      if (!jitterColor.checked || offset === 0) return baseColor;
      const [r, g, b] = hexToRgb(baseColor);
      const hsl = rgbToHsl(r, g, b);
      hsl.l += (Math.random() * 0.2 - 0.1); // ±10% lightness
      hsl.l = Math.max(0, Math.min(1, hsl.l));
      const [newR, newG, newB] = hslToRgb(hsl.h, hsl.s, hsl.l);
      return `rgb(${Math.round(newR)},${Math.round(newG)},${Math.round(newB)})`;
    }

    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return { h, s, l };
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return [r * 255, g * 255, b * 255];
    }

    function drawPositionPatternCanvas(row, col, moduleSize, roundness, blackColor, whiteColor) {
      const x = col * moduleSize;
      const y = row * moduleSize;
      const outerRadius = roundness * (moduleSize * 3.5);
      const middleRadius = roundness * (moduleSize * 2.5);
      const innerRadius = roundness * (moduleSize * 1.5);
      ctx.fillStyle = blackColor;
      drawRoundedRect(ctx, x, y, 7 * moduleSize, 7 * moduleSize, outerRadius);
      ctx.fillStyle = whiteColor;
      drawRoundedRect(ctx, x + moduleSize, y + moduleSize, 5 * moduleSize, 5 * moduleSize, middleRadius);
      ctx.fillStyle = blackColor;
      drawRoundedRect(ctx, x + 2 * moduleSize, y + 2 * moduleSize, 3 * moduleSize, 3 * moduleSize, innerRadius);
    }

    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.arcTo(x + width, y, x + width, y + radius, radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
      ctx.lineTo(x + radius, y + height);
      ctx.arcTo(x, y + height, x, y + height - radius, radius);
      ctx.lineTo(x, y + radius);
      ctx.arcTo(x, y, x + radius, y, radius);
      ctx.closePath();
      ctx.fill();
    }

    function isPositionPattern(i, j, n) {
      return (i < 7 && j < 7) || (i < 7 && j >= n - 7) || (i >= n - 7 && j < 7);
    }

    brushToggle.addEventListener('click', () => {
      brushEnabled = !brushEnabled;
      brushToggle.textContent = brushEnabled ? 'Disable Brush' : 'Enable Brush';
      qrCanvas.style.cursor = brushEnabled ? 'crosshair' : 'default';
      brushSilhouette.style.display = brushEnabled ? 'block' : 'none';
    });

    qrCanvas.addEventListener('mousemove', (event) => {
      if (brushEnabled) {
        const rect = qrCanvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const radius = parseInt(brushRadius.value) * (rect.width / (qrCode?.getModuleCount() || 1));
        brushSilhouette.style.width = `${radius * 2}px`;
        brushSilhouette.style.height = `${radius * 2}px`;
        brushSilhouette.style.left = `${x - radius}px`;
        brushSilhouette.style.top = `${y - radius}px`;
      }
      if (isBrushing) applyBrush(event);
    });

    qrCanvas.addEventListener('mousedown', (event) => {
      if (!brushEnabled || !qrCode) return;
      isBrushing = true;
      applyBrush(event);
    });

    qrCanvas.addEventListener('mouseup', () => {
      if (isBrushing) {
        if (history.length > 10) history.shift();
        history.push(new Map(brushedModules));
        historyIndex = history.length - 1;
        isBrushing = false;
      }
    });

    function applyBrush(event) {
      const rect = qrCanvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / rect.width;
      const y = (event.clientY - rect.top) / rect.height;
      const n = qrCode.getModuleCount();
      const radius = parseInt(brushRadius.value);
      const intensity = parseFloat(brushIntensity.value);
      const minScale = parseFloat(brushStrength.value);
      const maxTransparency = parseFloat(brushTransparency.value);
      const rotationDelta = parseFloat(rotationSpeed.value);
      const centerI = Math.floor(y * n);
      const centerJ = Math.floor(x * n);
      const maxDist = radius * radius;

      for (let di = -radius; di <= radius; di++) {
        for (let dj = -radius; dj <= radius; dj++) {
          const i = centerI + di;
          const j = centerJ + dj;
          if (i >= 0 && i < n && j >= 0 && j < n) {
            const dist = di * di + dj * dj;
            if (dist <= maxDist) {
              const key = `${i},${j}`;
              const current = brushedModules.get(key) || { scale: 1, transparency: 0, rotation: 0, colorOffset: 0 };
              const feather = 1 - (dist / maxDist);
              const delta = intensity * feather;

              if (!lockScale.checked) {
                const targetScale = minScale;
                const diff = targetScale - current.scale;
                current.scale += diff * delta * Math.pow(feather, 2);
                current.scale = Math.max(0.1, Math.min(1, current.scale));
                if (jitterScale.checked) {
                  current.scale *= 1 + (Math.random() - 0.5) * 0.1 * feather;
                  current.scale = Math.max(0.1, Math.min(1, current.scale));
                }
              }

              if (!lockTransparency.checked) {
                current.transparency = Math.min(maxTransparency, current.transparency + delta);
              }

              if (!lockRotation.checked && rotationDelta !== 0) {
                current.rotation += rotationDelta * feather;
                if (jitterRotation.checked) {
                  current.rotation += (Math.random() - 0.5) * 10 * feather;
                }
              }

              if (jitterColor.checked) {
                current.colorOffset += (Math.random() - 0.5) * 20 * feather;
                current.colorOffset = Math.max(-50, Math.min(50, current.colorOffset));
              }

              brushedModules.set(key, current);
            }
          }
        }
      }
      drawPreview();
    }

    resetRotationBtn.addEventListener('click', () => {
      rotationSpeed.value = 0;
      document.getElementById('rotation-speed-value').textContent = '0°';
      for (let [key, value] of brushedModules) {
        value.rotation = 0;
        brushedModules.set(key, value);
      }
      drawPreview();
    });

    resetColorsBtn.addEventListener('click', () => {
      for (let [key, value] of brushedModules) {
        value.colorOffset = 0;
        brushedModules.set(key, value);
      }
      drawPreview();
    });

    resetScaleBtn.addEventListener('click', () => {
      for (let [key, value] of brushedModules) {
        value.scale = 1;
        brushedModules.set(key, value);
      }
      drawPreview();
    });

    resetTransparencyBtn.addEventListener('click', () => {
      for (let [key, value] of brushedModules) {
        value.transparency = 0;
        brushedModules.set(key, value);
      }
      drawPreview();
    });

    resetAllBtn.addEventListener('click', () => {
      brushedModules.clear();
      drawPreview();
    });

    undoBtn.addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        brushedModules = new Map(history[historyIndex]);
        drawPreview();
      }
    });

    redoBtn.addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        brushedModules = new Map(history[historyIndex]);
        drawPreview();
      }
    });

    downloadBtn.addEventListener('click', () => {
      const svg = generateSVG();
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'qr-code.svg';
      link.click();
      URL.revokeObjectURL(url);
    });

    function generateSVG() {
      if (!qrCode) return '';
      const n = qrCode.getModuleCount();
      const moduleSize = 10;
      const svgSize = n * moduleSize;
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}">`;

      if (logoSVGCode || logoImage.src) {
        const canvasSize = previewContainer.clientWidth;
        const svgScaleFactor = svgSize / canvasSize;
        const logoWidth = logoBounds.width * svgScaleFactor;
        const logoHeight = logoBounds.height * svgScaleFactor;
        const x = logoBounds.x * svgScaleFactor;
        const y = logoBounds.y * svgScaleFactor;
        if (logoSVGCode) {
          const scaledLogoSVG = logoSVGCode.replace(/width="[^"]*"/, `width="${logoWidth}"`).replace(/height="[^"]*"/, `height="${logoHeight}"`);
          svg += `<svg x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}">${scaledLogoSVG}</svg>`;
        } else {
          svg += `<image href="${logoImage.src}" x="${x}" y="${y}" width="${logoWidth}" height="${logoHeight}"/>`;
        }
      }

      if (smoothCorners.checked) {
        const roundness = parseFloat(roundnessSlider.value);
        const outerRadius = roundness * (moduleSize * 3.5);
        const middleRadius = roundness * (moduleSize * 2.5);
        const innerRadius = roundness * (moduleSize * 1.5);
        svg += drawSVGRoundedPositionPattern(0, 0, moduleSize, outerRadius, middleRadius, innerRadius, blackColor, whiteColor);
        svg += drawSVGRoundedPositionPattern(0, n - 7, moduleSize, outerRadius, middleRadius, innerRadius, blackColor, whiteColor);
        svg += drawSVGRoundedPositionPattern(n - 7, 0, moduleSize, outerRadius, middleRadius, innerRadius, blackColor, whiteColor);
      }

      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if (smoothCorners.checked && isPositionPattern(i, j, n)) continue;
          const { scale, transparency, rotation, colorOffset } = getModuleProperties(i, j);
          const size = moduleSize * scale;
          const offset = (moduleSize - size) / 2;
          const x = j * moduleSize + offset;
          const y = i * moduleSize + offset;
          const baseColor = qrCode.isDark(i, j) ? blackColor : whiteColor;
          const jitteredColor = applyColorJitter(baseColor, colorOffset);
          const gradientId = `${i}_${j}_gradient`;
          svg += `<defs><radialGradient id="${gradientId}" cx="0.5" cy="0.5" r="0.5">
            <stop offset="0%" stop-color="${jitteredColor}" stop-opacity="1"/>
            <stop offset="100%" stop-color="${jitteredColor}" stop-opacity="${1 - transparency}"/>
          </radialGradient></defs>`;
          svg += `<rect x="${x}" y="${y}" width="${size}" height="${size}" fill="url(#${gradientId})" transform="rotate(${rotation}, ${x + size / 2}, ${y + size / 2})"/>`;
        }
      }
      svg += '</svg>';
      return svg;
    }

    function drawSVGRoundedPositionPattern(row, col, moduleSize, outerRadius, middleRadius, innerRadius, blackColor, whiteColor) {
      const x = col * moduleSize;
      const y = row * moduleSize;
      return `
        <rect x="${x}" y="${y}" width="${7 * moduleSize}" height="${7 * moduleSize}" fill="${blackColor}" rx="${outerRadius}"/>
        <rect x="${x + moduleSize}" y="${y + moduleSize}" width="${5 * moduleSize}" height="${5 * moduleSize}" fill="${whiteColor}" rx="${middleRadius}"/>
        <rect x="${x + 2 * moduleSize}" y="${y + 2 * moduleSize}" width="${3 * moduleSize}" height="${3 * moduleSize}" fill="${blackColor}" rx="${innerRadius}"/>
      `;
    }

    window.addEventListener('resize', drawPreview);
    generateQRCode();
  </script>
</body>
</html>
